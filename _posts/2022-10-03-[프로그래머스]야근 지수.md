---
title:  "[프로그래머스] 야근 지수"
categories: 
  - Problem Solving
sidebar:
    nav: "sideMenu"
tags:
  - 코딩테스트
  - 프로그래머스
  - Lv. 3
---
결론부터 얘기하면, 야근 지수를 최소화하기 위해서는 works에서 가장 큰 값을 구하여 1씩 빼는 작업을 n번 반복하면 된다.

그 이유는 문제에서 야근지수는 각 원소의 제곱의 합으로 산정한다고 되어 있기 때문에, 가장 큰 값을 매번 찾아서 줄여주는 것이 제일 작게 만드는 방법이다.

이제 가장 큰 값을 매번 찾아서 줄여주는 방법에 대해 고민해봐야 하는데, 첫 번째로 우선순위 큐(최대 힙)를 활용해서 루트 노드의 값에서 1을 빼면서 매번 업데이트 하는 방식을 고민해보았다.

업데이트 하는 데 걸리는 시간은 O(logN) 이므로, 백만 * log백만 = 백만 * 1000 = 10억 정도의 연산이 필요한 것으로 추정된다. (물론 1씩 줄이므로 실제 logN 보다는 짧을 것 같다만)

사실 이 문제를 풀기위해 라이브러리에서 제공해주지 않는 우선순위 큐의 업데이트 기능을 직접 만들어 사용할까도 싶었지만, 다른 방법이 있을 것 같아 고민을 해 보았다.(사실 우선순위 큐 업데이트 기능을 위해 직접 구현하는 건 만만치 않아서...)

사실, 최대값에서 1만 줄이고 매번 다음 최대값이 뭔지를 찾아 1을 줄이는 과정의 반복이므로, 이 방법을 굳이 우선순위 큐를 이용해서 업데이트 하는 것이 비효율적이며, 나름 간단한 방법을 고안하였다.

1. 내림차순 정렬한다.
2. 첫번 째 원소(최대 값)를 기준으로 그 다음 원소와 비교하면서 차이가 1 이상인(즉, 서로 다른 값) 경우에 해당 원소 이전까지의 원소들에 대해 전부 1씩 뺀다.
3. (2)의 수행을 해당 원소와 같아질 때까지 반복한다.
4. (3)의 과정을 거쳐 works의 모든 원소가 같아지면, 앞에서부터 n이 0이 될 때까지 1씩 차례대로 뺀다.
5. 위의 작업에서 원소를 빼는 작업 시 n의 값도 1 뺀다.
6. n이 0이 되면 위의 작업을 중단하고 works의 각 원소의 제곱의 합을 구해 반환한다.

```python

def solution(n, works):
    answer = 0
    total = 0
    for i in works:
        total += i
    if total <= n:
        return 0
    
    works.sort(reverse=True)
    
    flag = False
    
    for i in range(len(works) - 1):
        if works[i] > works[i + 1]:
            while works[i] > works[i + 1]:
                for j in range(i+1):
                    works[j] -= 1
                    n -= 1
                    if n == 0:
                        flag = True
                        break
                if flag == True:
                    break
            if flag == True:
                break
    
    while n > 0:
        for i in range(len(works)):
            works[i] -= 1
            n -= 1
            if n == 0:
                break
    
    for i in works:
        answer += i**2
    
    return answer
```

문제 풀 때에는 works의 원소 합보다 n이 큰 경우는 0으로 리턴하는 것을 먼저 정의하고 풀었다. 

놀라운 사실은 최초 작성 후 돌렸는데 한 번에 테스트케이스 AC를 받았다.(이런 경험이 거의 없어서 왠지 무서운 ㄷㄷ)

문제 푼 것과 별개로 반성할 점은 라이브러리에서 제공해주지 않는 우선순위 큐의 업데이트 기능을 직접 구현할 능력이 없다는 것이다. 

이 참에 우선순위 큐 직접 구현 방법(업데이트 기능 포함)을 자료구조 공부 겸 포스팅 해봐야겠다.(제발 꼭 까먹지말고....)

-> [우선순위 큐를 활용한 문제풀이][우선순위 큐를 활용한 문제풀이]

문제 링크: [프로그래머스 - 야근 지수][프로그래머스-야근 지수]

[프로그래머스-야근 지수]: https://school.programmers.co.kr/learn/courses/30/lessons/12927
[우선순위 큐를 활용한 문제풀이]: https://wowboya.github.io/problem%20solving/프로그래머스-야근-지수(우선순위-큐)/